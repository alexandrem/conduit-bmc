<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{.Title}}</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><rect width='20' height='14' x='2' y='3' rx='2' ry='2' fill='%2300ff00'/><circle cx='12' cy='10' r='2' fill='%23000'/></svg>">

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    animation: {
                        'pulse': 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>

    <!-- Page-specific libraries -->
    {{block "libraries" .}}{{end}}

    <style>
        {{block "styles" .}}{{end}}
    </style>
</head>
<body class="font-sans bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white overflow-hidden h-screen">
    <div class="bg-black/30 backdrop-blur-md border-b border-white/10 px-5 py-3 flex justify-between items-center z-50">
        <h1 class="text-lg font-semibold flex items-center gap-2">
            <div class="w-5 h-5 bg-green-400 rounded-sm flex items-center justify-center text-xs text-black font-bold">{{.IconText}}</div>
            {{.HeaderTitle}}
        </h1>
        <div class="flex items-center gap-1.5 px-3 py-1 rounded-full text-xs font-medium bg-white/10">
            <div class="w-2 h-2 rounded-full bg-yellow-400 animate-pulse" id="status-dot"></div>
            <span id="status">{{.InitialStatus}}</span>
        </div>
    </div>

    <div class="flex h-[calc(100vh-3.75rem)]">
        {{block "content" .}}{{end}}
    </div>

    <script>
        function updateStatus(text, type) {
            const status = document.getElementById('status');
            const statusDot = document.getElementById('status-dot');
            status.textContent = text;

            // Remove existing classes
            statusDot.className = 'w-2 h-2 rounded-full';

            // Add status-specific classes
            if (type === 'connected') {
                statusDot.classList.add('bg-green-400');
            } else if (type === 'error') {
                statusDot.classList.add('bg-red-400');
            } else {
                statusDot.classList.add('bg-yellow-400', 'animate-pulse');
            }
        }

        /**
         * ReconnectionManager - Manages automatic reconnection with exponential backoff
         *
         * Usage:
         *   const reconnectManager = new ReconnectionManager({
         *     onReconnect: () => { initializeConnection(); },
         *     onStateChange: (state) => { updateUI(state); },
         *     maxAttempts: 10,
         *     initialDelay: 1000,
         *     maxDelay: 30000
         *   });
         *
         *   // On connection success:
         *   reconnectManager.onConnected();
         *
         *   // On connection failure:
         *   reconnectManager.onDisconnected();
         *
         *   // To cancel auto-reconnection:
         *   reconnectManager.cancel();
         *
         *   // To manually trigger reconnection:
         *   reconnectManager.reconnectNow();
         */
        class ReconnectionManager {
            constructor(options = {}) {
                this.onReconnect = options.onReconnect || (() => {});
                this.onStateChange = options.onStateChange || (() => {});
                this.maxAttempts = options.maxAttempts || 10;
                this.initialDelay = options.initialDelay || 1000;
                this.maxDelay = options.maxDelay || 30000;

                this.enabled = true;
                this.attempts = 0;
                this.timeout = null;
                this.state = 'idle'; // idle, reconnecting, connected
            }

            /**
             * Calculate delay with exponential backoff
             */
            _calculateDelay() {
                return Math.min(
                    this.initialDelay * Math.pow(2, this.attempts),
                    this.maxDelay
                );
            }

            /**
             * Update internal state and notify listeners
             */
            _setState(newState, details = {}) {
                this.state = newState;
                this.onStateChange({
                    state: newState,
                    attempts: this.attempts,
                    maxAttempts: this.maxAttempts,
                    enabled: this.enabled,
                    ...details
                });
            }

            /**
             * Called when connection is successfully established
             */
            onConnected() {
                console.log('ReconnectionManager: Connection established');
                this.attempts = 0;
                this.enabled = true;
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
                this._setState('connected');
            }

            /**
             * Called when connection is lost
             */
            onDisconnected(reason = 'Connection lost') {
                console.log('ReconnectionManager: Connection lost -', reason);

                if (!this.enabled || this.attempts >= this.maxAttempts) {
                    const message = this.attempts >= this.maxAttempts
                        ? 'Max reconnection attempts reached'
                        : 'Auto-reconnection disabled';
                    console.log('ReconnectionManager:', message);
                    this._setState('failed', { reason: message });
                    return;
                }

                const delay = this._calculateDelay();
                this.attempts++;

                console.log(`ReconnectionManager: Scheduling reconnection ${this.attempts}/${this.maxAttempts} in ${delay}ms`);

                this._setState('reconnecting', {
                    delay: delay,
                    reason: reason
                });

                this.timeout = setTimeout(() => {
                    console.log('ReconnectionManager: Executing reconnection attempt', this.attempts);
                    this.onReconnect();
                }, delay);
            }

            /**
             * Cancel automatic reconnection
             */
            cancel() {
                console.log('ReconnectionManager: Auto-reconnection cancelled');
                this.enabled = false;
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
                this._setState('cancelled');
            }

            /**
             * Manually trigger immediate reconnection
             */
            reconnectNow() {
                console.log('ReconnectionManager: Manual reconnection triggered');
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
                this.onReconnect();
            }

            /**
             * Reset and restart reconnection process
             */
            reset() {
                console.log('ReconnectionManager: Reset');
                this.enabled = true;
                this.attempts = 0;
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
                this._setState('idle');
            }

            /**
             * Get current reconnection state
             */
            getState() {
                return {
                    state: this.state,
                    attempts: this.attempts,
                    maxAttempts: this.maxAttempts,
                    enabled: this.enabled
                };
            }
        }

        // Shared BMC Info functionality (used by both console.html and vnc.html)
        let bmcInfoData = null;

        async function fetchBMCInfo() {
            const serverID = '{{.ServerID}}';
            if (!serverID) return;

            try {
                const response = await fetch('/gateway.v1.GatewayService/GetBMCInfo', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        server_id: serverID
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    bmcInfoData = result.info;
                    updateBMCInfoDisplay();
                    if (typeof logToTerminal === 'function') {
                        logToTerminal('BMC hardware info loaded', 'success');
                    }
                } else {
                    const error = await response.text();
                    console.error('Failed to fetch BMC info:', error);
                    updateBMCInfoError();
                }
            } catch (error) {
                console.error('Error fetching BMC info:', error);
                updateBMCInfoError();
            }
        }

        function updateBMCInfoDisplay() {
            if (!bmcInfoData) return;

            const bmcType = document.getElementById('bmc-type');
            const bmcFirmware = document.getElementById('bmc-firmware');
            const bmcManufacturer = document.getElementById('bmc-manufacturer');
            const bmcVersion = document.getElementById('bmc-version');

            const type = bmcInfoData.bmc_type || bmcInfoData.bmcType || 'unknown';

            if (bmcType) {
                bmcType.textContent = type.toUpperCase();
                bmcType.className = 'px-2 py-0.5 text-xs font-medium rounded ' +
                    (type === 'ipmi' ? 'bg-blue-600/50' : type === 'redfish' ? 'bg-purple-600/50' : 'bg-gray-600/50');
            }

            // Support both snake_case and camelCase field names (protobuf JSON uses camelCase)
            const ipmiInfo = bmcInfoData.ipmi_info || bmcInfoData.ipmiInfo;
            const redfishInfo = bmcInfoData.redfish_info || bmcInfoData.redfishInfo;

            if (type === 'ipmi' && ipmiInfo) {
                if (bmcFirmware) bmcFirmware.textContent = ipmiInfo.firmware_revision || ipmiInfo.firmwareRevision || 'Unknown';
                if (bmcManufacturer) bmcManufacturer.textContent = ipmiInfo.manufacturer_name || ipmiInfo.manufacturerName || ipmiInfo.manufacturer_id || ipmiInfo.manufacturerId || 'Unknown';
                if (bmcVersion) bmcVersion.textContent = ipmiInfo.ipmi_version || ipmiInfo.ipmiVersion || 'Unknown';

                // IPMI doesn't support boot status - show unavailable message
                updateBootStatusDisplay(null);
            } else if (type === 'redfish' && redfishInfo) {
                if (bmcFirmware) bmcFirmware.textContent = redfishInfo.firmware_version || redfishInfo.firmwareVersion || 'Unknown';
                if (bmcManufacturer) bmcManufacturer.textContent = redfishInfo.manufacturer || 'Unknown';
                if (bmcVersion) bmcVersion.textContent = redfishInfo.model || 'Unknown';

                // Update boot status if available (RFD 020) - support both naming conventions
                const systemStatus = redfishInfo.system_status || redfishInfo.systemStatus;
                updateBootStatusDisplay(systemStatus);
            } else {
                // Unknown BMC type - show unavailable message
                updateBootStatusDisplay(null);
            }
        }

        // Boot Status Display (RFD 020 - Redfish only)
        function updateBootStatusDisplay(systemStatus) {
            const bootStatusSection = document.getElementById('boot-status-section');
            const bootStatusContent = document.getElementById('boot-status-content');
            const bootStatusUnavailable = document.getElementById('boot-status-unavailable');

            // Support both snake_case and camelCase field names
            const bootProgressValue = systemStatus?.boot_progress || systemStatus?.bootProgress;

            if (!systemStatus || !bootProgressValue) {
                // Show unavailable message, hide content
                if (bootStatusContent) bootStatusContent.style.display = 'none';
                if (bootStatusUnavailable) bootStatusUnavailable.style.display = 'block';
                return;
            }

            // Show content, hide unavailable message
            if (bootStatusContent) bootStatusContent.style.display = 'block';
            if (bootStatusUnavailable) bootStatusUnavailable.style.display = 'none';

            const bootProgress = document.getElementById('boot-progress');
            const bootProgressOem = document.getElementById('boot-progress-oem');
            const bootProgressOemRow = document.getElementById('boot-progress-oem-row');
            const postState = document.getElementById('post-state');
            const postStateRow = document.getElementById('post-state-row');
            const bootSource = document.getElementById('boot-source');
            const bootHint = document.getElementById('boot-hint');
            const bootHintText = document.getElementById('boot-hint-text');
            const bootStatusDot = document.getElementById('boot-status-dot');

            // Update boot progress with color coding
            if (bootProgress && bootProgressValue) {
                const progress = bootProgressValue;
                bootProgress.textContent = formatBootProgress(progress);
                bootProgress.className = 'px-2 py-1 text-xs font-medium rounded-full';

                if (progress === 'OSRunning' || progress === 'OSBootStarted') {
                    bootProgress.classList.add('bg-green-600', 'text-white');
                    if (bootStatusDot) bootStatusDot.className = 'w-2 h-2 bg-green-400 rounded-full';
                } else if (progress === 'SetupEntered' || progress === 'OEM') {
                    bootProgress.classList.add('bg-yellow-600', 'text-white');
                    if (bootStatusDot) bootStatusDot.className = 'w-2 h-2 bg-yellow-400 rounded-full pulse-animation';
                } else if (progress === 'None' || !progress) {
                    bootProgress.classList.add('bg-gray-600', 'text-white');
                    if (bootStatusDot) bootStatusDot.className = 'w-2 h-2 bg-gray-400 rounded-full';
                } else {
                    bootProgress.classList.add('bg-blue-600', 'text-white');
                    if (bootStatusDot) bootStatusDot.className = 'w-2 h-2 bg-blue-400 rounded-full pulse-animation';
                }
            }

            // Show OEM boot progress if present (Dell iDRAC) - support both naming conventions
            const bootProgressOemValue = systemStatus.boot_progress_oem || systemStatus.bootProgressOem;
            if (bootProgressOem && bootProgressOemRow && bootProgressOemValue) {
                bootProgressOem.textContent = bootProgressOemValue;
                bootProgressOemRow.style.display = 'flex';
            } else if (bootProgressOemRow) {
                bootProgressOemRow.style.display = 'none';
            }

            // Show POST state if present - support both naming conventions
            const postStateValue = systemStatus.post_state || systemStatus.postState;
            if (postState && postStateRow && postStateValue) {
                postState.textContent = postStateValue;
                postState.className = 'px-2 py-1 text-xs font-medium rounded-full';
                if (postStateValue === 'Completed') {
                    postState.classList.add('bg-green-600', 'text-white');
                } else if (postStateValue === 'Failed') {
                    postState.classList.add('bg-red-600', 'text-white');
                } else {
                    postState.classList.add('bg-blue-600', 'text-white');
                }
                postStateRow.style.display = 'flex';
            } else if (postStateRow) {
                postStateRow.style.display = 'none';
            }

            // Update boot source - support both naming conventions
            const bootSourceValue = systemStatus.boot_source || systemStatus.bootSource;
            if (bootSource && bootSourceValue) {
                const target = bootSourceValue.target || 'None';
                const mode = bootSourceValue.mode || 'Unknown';
                const enabled = bootSourceValue.enabled || 'Disabled';
                bootSource.textContent = `${target} (${mode}, ${enabled})`;
            }

            // Show contextual hints
            if (bootHint && bootHintText) {
                const hint = getBootHint(systemStatus);
                if (hint) {
                    bootHintText.textContent = hint;
                    bootHint.style.display = 'block';
                } else {
                    bootHint.style.display = 'none';
                }
            }
        }

        // Format boot progress for display
        function formatBootProgress(progress) {
            const map = {
                'None': 'None',
                'PrimaryProcessorInitializationStarted': 'CPU Init',
                'MemoryInitializationStarted': 'Memory Init',
                'SecondaryProcessorInitializationStarted': 'Multi-CPU Init',
                'PCIResourceConfigStarted': 'PCIe Config',
                'SystemHardwareInitializationComplete': 'POST Complete',
                'SetupEntered': 'BIOS Setup',
                'OSBootStarted': 'OS Booting',
                'OSRunning': 'OS Running',
                'OEM': 'OEM Status'
            };
            return map[progress] || progress;
        }

        // Get contextual hint based on boot state
        function getBootHint(systemStatus) {
            // Support both snake_case and camelCase field names
            const progress = systemStatus.boot_progress || systemStatus.bootProgress;
            const oemStatus = systemStatus.boot_progress_oem || systemStatus.bootProgressOem;

            if (progress === 'SetupEntered') {
                return '⚠ Server in BIOS Setup mode. Use VNC for graphical access.';
            } else if (progress === 'OEM' && oemStatus && oemStatus.toLowerCase().includes('no bootable')) {
                return '⚠ No bootable devices. Check boot config or use VNC to access BIOS.';
            } else if (progress === 'MemoryInitializationStarted' || progress === 'PrimaryProcessorInitializationStarted' || progress === 'PCIResourceConfigStarted') {
                return 'ℹ Early POST phase. VGA only - use VNC if console is blank.';
            }
            return null;
        }

        function updateBMCInfoError() {
            const bmcType = document.getElementById('bmc-type');
            if (bmcType) {
                bmcType.textContent = 'Error';
                bmcType.className = 'text-xs text-red-400';
            }
        }

        function toggleBMCInfo() {
            const content = document.getElementById('bmc-info-content');
            const toggle = document.getElementById('bmc-info-toggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        function showBMCDetails() {
            if (!bmcInfoData) {
                console.warn('BMC info not loaded yet');
                return;
            }

            const type = bmcInfoData.bmc_type || bmcInfoData.bmcType;
            let detailsHTML = '';

            // Support both snake_case and camelCase field names
            const ipmiInfo = bmcInfoData.ipmi_info || bmcInfoData.ipmiInfo;
            const redfishInfo = bmcInfoData.redfish_info || bmcInfoData.redfishInfo;

            if (type === 'ipmi' && ipmiInfo) {
                const info = ipmiInfo;
                detailsHTML = `
                    <div class="space-y-3">
                        <h4 class="font-semibold text-lg mb-3">IPMI Hardware Details</h4>
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div class="text-white/70">Device ID:</div>
                            <div class="font-mono">${info.device_id || info.deviceId || 'N/A'}</div>

                            <div class="text-white/70">Device Revision:</div>
                            <div class="font-mono">${info.device_revision || info.deviceRevision || 'N/A'}</div>

                            <div class="text-white/70">Firmware Revision:</div>
                            <div class="font-mono">${info.firmware_revision || info.firmwareRevision || 'N/A'}</div>

                            <div class="text-white/70">IPMI Version:</div>
                            <div class="font-mono">${info.ipmi_version || info.ipmiVersion || 'N/A'}</div>

                            <div class="text-white/70">Manufacturer ID:</div>
                            <div class="font-mono">${info.manufacturer_id || info.manufacturerId || 'N/A'}</div>

                            <div class="text-white/70">Manufacturer Name:</div>
                            <div class="font-mono">${info.manufacturer_name || info.manufacturerName || 'Unknown'}</div>

                            <div class="text-white/70">Product ID:</div>
                            <div class="font-mono">${info.product_id || info.productId || 'N/A'}</div>

                            <div class="text-white/70">Device Available:</div>
                            <div>${(info.device_available !== undefined ? info.device_available : info.deviceAvailable) ? '✓ Yes' : '✗ No'}</div>

                            <div class="text-white/70">Provides SDRs:</div>
                            <div>${(info.provides_device_sdrs !== undefined ? info.provides_device_sdrs : info.providesDeviceSdrs) ? '✓ Yes' : '✗ No'}</div>
                        </div>
                        ${(info.additional_device_support || info.additionalDeviceSupport || []).length > 0 ? `
                            <div class="mt-4">
                                <div class="text-white/70 mb-2">Additional Device Support:</div>
                                <ul class="list-disc list-inside text-sm space-y-1">
                                    ${(info.additional_device_support || info.additionalDeviceSupport).map(s => `<li>${s}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                `;
            } else if (type === 'redfish' && redfishInfo) {
                const info = redfishInfo;
                detailsHTML = `
                    <div class="space-y-3">
                        <h4 class="font-semibold text-lg mb-3">Redfish Manager Details</h4>
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div class="text-white/70">Manager ID:</div>
                            <div class="font-mono">${info.manager_id || info.managerId || 'N/A'}</div>

                            <div class="text-white/70">Name:</div>
                            <div>${info.name || 'N/A'}</div>

                            <div class="text-white/70">Model:</div>
                            <div>${info.model || 'N/A'}</div>

                            <div class="text-white/70">Manufacturer:</div>
                            <div>${info.manufacturer || 'N/A'}</div>

                            <div class="text-white/70">Firmware Version:</div>
                            <div class="font-mono">${info.firmware_version || info.firmwareVersion || 'N/A'}</div>

                            <div class="text-white/70">Status:</div>
                            <div>${info.status || 'N/A'}</div>

                            <div class="text-white/70">Power State:</div>
                            <div>${info.power_state || info.powerState || 'N/A'}</div>
                        </div>
                        ${(info.network_protocols || info.networkProtocols || []).length > 0 ? `
                            <div class="mt-4">
                                <div class="text-white/70 mb-2">Network Protocols:</div>
                                <ul class="list-disc list-inside text-sm space-y-1">
                                    ${(info.network_protocols || info.networkProtocols).map(p => `<li>${p.name} (port ${p.port})${p.enabled ? '' : ' - Disabled'}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                `;
            } else {
                detailsHTML = '<p class="text-white/70">No detailed information available</p>';
            }

            // Create modal
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-gradient-to-br from-gray-900 to-black border border-white/20 rounded-xl p-6 max-w-2xl w-full max-h-[80vh] overflow-y-auto">
                    ${detailsHTML}
                    <button onclick="this.closest('.fixed').remove()"
                            class="w-full mt-6 p-3 bg-gradient-to-r from-blue-500 to-purple-600 rounded-lg font-medium transition-all hover:-translate-y-0.5">
                        Close
                    </button>
                </div>
            `;

            document.body.appendChild(modal);

            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        {{block "scripts" .}}{{end}}
    </script>
</body>
</html>
