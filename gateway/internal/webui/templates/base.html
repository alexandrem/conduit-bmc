<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{.Title}}</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><rect width='20' height='14' x='2' y='3' rx='2' ry='2' fill='%2300ff00'/><circle cx='12' cy='10' r='2' fill='%23000'/></svg>">

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    animation: {
                        'pulse': 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>

    <!-- Page-specific libraries -->
    {{block "libraries" .}}{{end}}

    <style>
        {{block "styles" .}}{{end}}
    </style>
</head>
<body class="font-sans bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white overflow-hidden h-screen">
    <div class="bg-black/30 backdrop-blur-md border-b border-white/10 px-5 py-3 flex justify-between items-center z-50">
        <h1 class="text-lg font-semibold flex items-center gap-2">
            <div class="w-5 h-5 bg-green-400 rounded-sm flex items-center justify-center text-xs text-black font-bold">{{.IconText}}</div>
            {{.HeaderTitle}}
        </h1>
        <div class="flex items-center gap-1.5 px-3 py-1 rounded-full text-xs font-medium bg-white/10">
            <div class="w-2 h-2 rounded-full bg-yellow-400 animate-pulse" id="status-dot"></div>
            <span id="status">{{.InitialStatus}}</span>
        </div>
    </div>

    <div class="flex h-[calc(100vh-3.75rem)]">
        {{block "content" .}}{{end}}
    </div>

    <script>
        function updateStatus(text, type) {
            const status = document.getElementById('status');
            const statusDot = document.getElementById('status-dot');
            status.textContent = text;

            // Remove existing classes
            statusDot.className = 'w-2 h-2 rounded-full';

            // Add status-specific classes
            if (type === 'connected') {
                statusDot.classList.add('bg-green-400');
            } else if (type === 'error') {
                statusDot.classList.add('bg-red-400');
            } else {
                statusDot.classList.add('bg-yellow-400', 'animate-pulse');
            }
        }

        /**
         * ReconnectionManager - Manages automatic reconnection with exponential backoff
         *
         * Usage:
         *   const reconnectManager = new ReconnectionManager({
         *     onReconnect: () => { initializeConnection(); },
         *     onStateChange: (state) => { updateUI(state); },
         *     maxAttempts: 10,
         *     initialDelay: 1000,
         *     maxDelay: 30000
         *   });
         *
         *   // On connection success:
         *   reconnectManager.onConnected();
         *
         *   // On connection failure:
         *   reconnectManager.onDisconnected();
         *
         *   // To cancel auto-reconnection:
         *   reconnectManager.cancel();
         *
         *   // To manually trigger reconnection:
         *   reconnectManager.reconnectNow();
         */
        class ReconnectionManager {
            constructor(options = {}) {
                this.onReconnect = options.onReconnect || (() => {});
                this.onStateChange = options.onStateChange || (() => {});
                this.maxAttempts = options.maxAttempts || 10;
                this.initialDelay = options.initialDelay || 1000;
                this.maxDelay = options.maxDelay || 30000;

                this.enabled = true;
                this.attempts = 0;
                this.timeout = null;
                this.state = 'idle'; // idle, reconnecting, connected
            }

            /**
             * Calculate delay with exponential backoff
             */
            _calculateDelay() {
                return Math.min(
                    this.initialDelay * Math.pow(2, this.attempts),
                    this.maxDelay
                );
            }

            /**
             * Update internal state and notify listeners
             */
            _setState(newState, details = {}) {
                this.state = newState;
                this.onStateChange({
                    state: newState,
                    attempts: this.attempts,
                    maxAttempts: this.maxAttempts,
                    enabled: this.enabled,
                    ...details
                });
            }

            /**
             * Called when connection is successfully established
             */
            onConnected() {
                console.log('ReconnectionManager: Connection established');
                this.attempts = 0;
                this.enabled = true;
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
                this._setState('connected');
            }

            /**
             * Called when connection is lost
             */
            onDisconnected(reason = 'Connection lost') {
                console.log('ReconnectionManager: Connection lost -', reason);

                if (!this.enabled || this.attempts >= this.maxAttempts) {
                    const message = this.attempts >= this.maxAttempts
                        ? 'Max reconnection attempts reached'
                        : 'Auto-reconnection disabled';
                    console.log('ReconnectionManager:', message);
                    this._setState('failed', { reason: message });
                    return;
                }

                const delay = this._calculateDelay();
                this.attempts++;

                console.log(`ReconnectionManager: Scheduling reconnection ${this.attempts}/${this.maxAttempts} in ${delay}ms`);

                this._setState('reconnecting', {
                    delay: delay,
                    reason: reason
                });

                this.timeout = setTimeout(() => {
                    console.log('ReconnectionManager: Executing reconnection attempt', this.attempts);
                    this.onReconnect();
                }, delay);
            }

            /**
             * Cancel automatic reconnection
             */
            cancel() {
                console.log('ReconnectionManager: Auto-reconnection cancelled');
                this.enabled = false;
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
                this._setState('cancelled');
            }

            /**
             * Manually trigger immediate reconnection
             */
            reconnectNow() {
                console.log('ReconnectionManager: Manual reconnection triggered');
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
                this.onReconnect();
            }

            /**
             * Reset and restart reconnection process
             */
            reset() {
                console.log('ReconnectionManager: Reset');
                this.enabled = true;
                this.attempts = 0;
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
                this._setState('idle');
            }

            /**
             * Get current reconnection state
             */
            getState() {
                return {
                    state: this.state,
                    attempts: this.attempts,
                    maxAttempts: this.maxAttempts,
                    enabled: this.enabled
                };
            }
        }

        // Shared BMC Info functionality (used by both console.html and vnc.html)
        let bmcInfoData = null;

        async function fetchBMCInfo() {
            const serverID = '{{.ServerID}}';
            if (!serverID) return;

            try {
                const response = await fetch('/gateway.v1.GatewayService/GetBMCInfo', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        server_id: serverID
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    bmcInfoData = result.info;
                    updateBMCInfoDisplay();
                    if (typeof logToTerminal === 'function') {
                        logToTerminal('BMC hardware info loaded', 'success');
                    }
                } else {
                    const error = await response.text();
                    console.error('Failed to fetch BMC info:', error);
                    updateBMCInfoError();
                }
            } catch (error) {
                console.error('Error fetching BMC info:', error);
                updateBMCInfoError();
            }
        }

        function updateBMCInfoDisplay() {
            if (!bmcInfoData) return;

            const bmcType = document.getElementById('bmc-type');
            const bmcFirmware = document.getElementById('bmc-firmware');
            const bmcManufacturer = document.getElementById('bmc-manufacturer');
            const bmcVersion = document.getElementById('bmc-version');

            const type = bmcInfoData.bmc_type || bmcInfoData.bmcType || 'unknown';

            if (bmcType) {
                bmcType.textContent = type.toUpperCase();
                bmcType.className = 'px-2 py-0.5 text-xs font-medium rounded ' +
                    (type === 'ipmi' ? 'bg-blue-600/50' : type === 'redfish' ? 'bg-purple-600/50' : 'bg-gray-600/50');
            }

            if (type === 'ipmi' && bmcInfoData.ipmi_info) {
                const info = bmcInfoData.ipmi_info;
                if (bmcFirmware) bmcFirmware.textContent = info.firmware_revision || 'Unknown';
                if (bmcManufacturer) bmcManufacturer.textContent = info.manufacturer_name || info.manufacturer_id || 'Unknown';
                if (bmcVersion) bmcVersion.textContent = info.ipmi_version || 'Unknown';
            } else if (type === 'redfish' && bmcInfoData.redfish_info) {
                const info = bmcInfoData.redfish_info;
                if (bmcFirmware) bmcFirmware.textContent = info.firmware_version || 'Unknown';
                if (bmcManufacturer) bmcManufacturer.textContent = info.manufacturer || 'Unknown';
                if (bmcVersion) bmcVersion.textContent = info.model || 'Unknown';
            }
        }

        function updateBMCInfoError() {
            const bmcType = document.getElementById('bmc-type');
            if (bmcType) {
                bmcType.textContent = 'Error';
                bmcType.className = 'text-xs text-red-400';
            }
        }

        function toggleBMCInfo() {
            const content = document.getElementById('bmc-info-content');
            const toggle = document.getElementById('bmc-info-toggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }

        function showBMCDetails() {
            if (!bmcInfoData) {
                console.warn('BMC info not loaded yet');
                return;
            }

            const type = bmcInfoData.bmc_type || bmcInfoData.bmcType;
            let detailsHTML = '';

            if (type === 'ipmi' && bmcInfoData.ipmi_info) {
                const info = bmcInfoData.ipmi_info;
                detailsHTML = `
                    <div class="space-y-3">
                        <h4 class="font-semibold text-lg mb-3">IPMI Hardware Details</h4>
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div class="text-white/70">Device ID:</div>
                            <div class="font-mono">${info.device_id || 'N/A'}</div>

                            <div class="text-white/70">Device Revision:</div>
                            <div class="font-mono">${info.device_revision || 'N/A'}</div>

                            <div class="text-white/70">Firmware Revision:</div>
                            <div class="font-mono">${info.firmware_revision || 'N/A'}</div>

                            <div class="text-white/70">IPMI Version:</div>
                            <div class="font-mono">${info.ipmi_version || 'N/A'}</div>

                            <div class="text-white/70">Manufacturer ID:</div>
                            <div class="font-mono">${info.manufacturer_id || 'N/A'}</div>

                            <div class="text-white/70">Manufacturer Name:</div>
                            <div class="font-mono">${info.manufacturer_name || 'Unknown'}</div>

                            <div class="text-white/70">Product ID:</div>
                            <div class="font-mono">${info.product_id || 'N/A'}</div>

                            <div class="text-white/70">Device Available:</div>
                            <div>${info.device_available ? '✓ Yes' : '✗ No'}</div>

                            <div class="text-white/70">Provides SDRs:</div>
                            <div>${info.provides_device_sdrs ? '✓ Yes' : '✗ No'}</div>
                        </div>
                        ${info.additional_device_support && info.additional_device_support.length > 0 ? `
                            <div class="mt-4">
                                <div class="text-white/70 mb-2">Additional Device Support:</div>
                                <ul class="list-disc list-inside text-sm space-y-1">
                                    ${info.additional_device_support.map(s => `<li>${s}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                `;
            } else if (type === 'redfish' && bmcInfoData.redfish_info) {
                const info = bmcInfoData.redfish_info;
                detailsHTML = `
                    <div class="space-y-3">
                        <h4 class="font-semibold text-lg mb-3">Redfish Manager Details</h4>
                        <div class="grid grid-cols-2 gap-2 text-sm">
                            <div class="text-white/70">Manager ID:</div>
                            <div class="font-mono">${info.manager_id || 'N/A'}</div>

                            <div class="text-white/70">Name:</div>
                            <div>${info.name || 'N/A'}</div>

                            <div class="text-white/70">Model:</div>
                            <div>${info.model || 'N/A'}</div>

                            <div class="text-white/70">Manufacturer:</div>
                            <div>${info.manufacturer || 'N/A'}</div>

                            <div class="text-white/70">Firmware Version:</div>
                            <div class="font-mono">${info.firmware_version || 'N/A'}</div>

                            <div class="text-white/70">Status:</div>
                            <div>${info.status || 'N/A'}</div>

                            <div class="text-white/70">Power State:</div>
                            <div>${info.power_state || 'N/A'}</div>
                        </div>
                        ${info.network_protocols && info.network_protocols.length > 0 ? `
                            <div class="mt-4">
                                <div class="text-white/70 mb-2">Network Protocols:</div>
                                <ul class="list-disc list-inside text-sm space-y-1">
                                    ${info.network_protocols.map(p => `<li>${p.name} (port ${p.port})${p.enabled ? '' : ' - Disabled'}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                `;
            } else {
                detailsHTML = '<p class="text-white/70">No detailed information available</p>';
            }

            // Create modal
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-gradient-to-br from-gray-900 to-black border border-white/20 rounded-xl p-6 max-w-2xl w-full max-h-[80vh] overflow-y-auto">
                    ${detailsHTML}
                    <button onclick="this.closest('.fixed').remove()"
                            class="w-full mt-6 p-3 bg-gradient-to-r from-blue-500 to-purple-600 rounded-lg font-medium transition-all hover:-translate-y-0.5">
                        Close
                    </button>
                </div>
            `;

            document.body.appendChild(modal);

            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        {{block "scripts" .}}{{end}}
    </script>
</body>
</html>
