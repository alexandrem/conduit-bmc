<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{.Title}}</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><rect width='20' height='14' x='2' y='3' rx='2' ry='2' fill='%2300ff00'/><circle cx='12' cy='10' r='2' fill='%23000'/></svg>">

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    animation: {
                        'pulse': 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>

    <!-- XTerm.js for terminal emulation -->
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.9.0/lib/xterm-addon-web-links.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />

    <!-- noVNC for VNC viewer -->
    <script type="module">
        import RFBModule from 'https://cdn.jsdelivr.net/npm/@novnc/novnc@1.4.0/core/rfb.js';
        window.RFB = RFBModule;
    </script>
    <style>
        {{block "styles" .}}{{end}}
    </style>
</head>
<body class="font-sans bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white overflow-hidden h-screen">
    <div class="bg-black/30 backdrop-blur-md border-b border-white/10 px-5 py-3 flex justify-between items-center z-50">
        <h1 class="text-lg font-semibold flex items-center gap-2">
            <div class="w-5 h-5 bg-green-400 rounded-sm flex items-center justify-center text-xs text-black font-bold">{{.IconText}}</div>
            {{.HeaderTitle}}
        </h1>
        <div class="flex items-center gap-1.5 px-3 py-1 rounded-full text-xs font-medium bg-white/10">
            <div class="w-2 h-2 rounded-full bg-yellow-400 animate-pulse" id="status-dot"></div>
            <span id="status">{{.InitialStatus}}</span>
        </div>
    </div>

    <div class="flex h-[calc(100vh-3.75rem)]">
        {{block "content" .}}{{end}}
    </div>

    <script>
        function updateStatus(text, type) {
            const status = document.getElementById('status');
            const statusDot = document.getElementById('status-dot');
            status.textContent = text;

            // Remove existing classes
            statusDot.className = 'w-2 h-2 rounded-full';

            // Add status-specific classes
            if (type === 'connected') {
                statusDot.classList.add('bg-green-400');
            } else if (type === 'error') {
                statusDot.classList.add('bg-red-400');
            } else {
                statusDot.classList.add('bg-yellow-400', 'animate-pulse');
            }
        }

        /**
         * ReconnectionManager - Manages automatic reconnection with exponential backoff
         *
         * Usage:
         *   const reconnectManager = new ReconnectionManager({
         *     onReconnect: () => { initializeConnection(); },
         *     onStateChange: (state) => { updateUI(state); },
         *     maxAttempts: 10,
         *     initialDelay: 1000,
         *     maxDelay: 30000
         *   });
         *
         *   // On connection success:
         *   reconnectManager.onConnected();
         *
         *   // On connection failure:
         *   reconnectManager.onDisconnected();
         *
         *   // To cancel auto-reconnection:
         *   reconnectManager.cancel();
         *
         *   // To manually trigger reconnection:
         *   reconnectManager.reconnectNow();
         */
        class ReconnectionManager {
            constructor(options = {}) {
                this.onReconnect = options.onReconnect || (() => {});
                this.onStateChange = options.onStateChange || (() => {});
                this.maxAttempts = options.maxAttempts || 10;
                this.initialDelay = options.initialDelay || 1000;
                this.maxDelay = options.maxDelay || 30000;

                this.enabled = true;
                this.attempts = 0;
                this.timeout = null;
                this.state = 'idle'; // idle, reconnecting, connected
            }

            /**
             * Calculate delay with exponential backoff
             */
            _calculateDelay() {
                return Math.min(
                    this.initialDelay * Math.pow(2, this.attempts),
                    this.maxDelay
                );
            }

            /**
             * Update internal state and notify listeners
             */
            _setState(newState, details = {}) {
                this.state = newState;
                this.onStateChange({
                    state: newState,
                    attempts: this.attempts,
                    maxAttempts: this.maxAttempts,
                    enabled: this.enabled,
                    ...details
                });
            }

            /**
             * Called when connection is successfully established
             */
            onConnected() {
                console.log('ReconnectionManager: Connection established');
                this.attempts = 0;
                this.enabled = true;
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
                this._setState('connected');
            }

            /**
             * Called when connection is lost
             */
            onDisconnected(reason = 'Connection lost') {
                console.log('ReconnectionManager: Connection lost -', reason);

                if (!this.enabled || this.attempts >= this.maxAttempts) {
                    const message = this.attempts >= this.maxAttempts
                        ? 'Max reconnection attempts reached'
                        : 'Auto-reconnection disabled';
                    console.log('ReconnectionManager:', message);
                    this._setState('failed', { reason: message });
                    return;
                }

                const delay = this._calculateDelay();
                this.attempts++;

                console.log(`ReconnectionManager: Scheduling reconnection ${this.attempts}/${this.maxAttempts} in ${delay}ms`);

                this._setState('reconnecting', {
                    delay: delay,
                    reason: reason
                });

                this.timeout = setTimeout(() => {
                    console.log('ReconnectionManager: Executing reconnection attempt', this.attempts);
                    this.onReconnect();
                }, delay);
            }

            /**
             * Cancel automatic reconnection
             */
            cancel() {
                console.log('ReconnectionManager: Auto-reconnection cancelled');
                this.enabled = false;
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
                this._setState('cancelled');
            }

            /**
             * Manually trigger immediate reconnection
             */
            reconnectNow() {
                console.log('ReconnectionManager: Manual reconnection triggered');
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
                this.onReconnect();
            }

            /**
             * Reset and restart reconnection process
             */
            reset() {
                console.log('ReconnectionManager: Reset');
                this.enabled = true;
                this.attempts = 0;
                if (this.timeout) {
                    clearTimeout(this.timeout);
                    this.timeout = null;
                }
                this._setState('idle');
            }

            /**
             * Get current reconnection state
             */
            getState() {
                return {
                    state: this.state,
                    attempts: this.attempts,
                    maxAttempts: this.maxAttempts,
                    enabled: this.enabled
                };
            }
        }

        {{block "scripts" .}}{{end}}
    </script>
</body>
</html>
