{{template "base.html" .}}

{{define "libraries"}}
<!-- XTerm.js for terminal emulation -->
<script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-web-links@0.9.0/lib/xterm-addon-web-links.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
{{end}}

{{define "styles"}}{{end}}

{{define "content"}}
<!-- Console Area -->
<div class="flex-1 flex flex-col bg-black/20 m-3 rounded-xl overflow-hidden backdrop-blur-md border border-white/10">
    <!-- SOL Console Header -->
    <div class="bg-black/40 p-4 border-b border-white/10 flex justify-between items-center flex-shrink-0">
        <div class="text-sm font-medium opacity-90 flex items-center gap-2">
            <span class="text-lg">üìü</span>
            SOL Console Session
        </div>
        <div class="flex gap-2">
            <button onclick="switchToVNC()" class="px-3 py-2 bg-gradient-to-r from-green-500 to-teal-600 rounded-md text-sm font-medium transition-all hover:-translate-y-0.5 text-white">
                üñ•Ô∏è Switch to VNC
            </button>
            <button onclick="sendCtrlAltDel()"
                    class="px-3 py-1 text-xs font-medium bg-white/10 hover:bg-white/20 border border-white/20 rounded-md transition-all hover:-translate-y-px">
                Ctrl+Alt+Del
            </button>
            <button onclick="toggleFullscreen()"
                    class="px-3 py-1 text-xs font-medium bg-gradient-to-r from-blue-500 to-purple-600 rounded-md transition-all hover:-translate-y-px">
                Fullscreen
            </button>
            <button onclick="cancelAutoReconnect()" id="cancel-reconnect-btn"
                    class="px-3 py-1 text-xs font-medium bg-gradient-to-r from-orange-500 to-red-500 rounded-md transition-all hover:-translate-y-px hidden">
                Cancel Auto-Reconnect
            </button>
            <button onclick="reconnect()"
                    class="px-3 py-1 text-xs font-medium bg-gradient-to-r from-red-500 to-orange-500 rounded-md transition-all hover:-translate-y-px">
                Reconnect
            </button>
        </div>
    </div>

    <!-- Terminal Container (with calculated height to leave room for other elements) -->
    <div id="terminal-container" class="flex-1 min-h-0 bg-console-bg"></div>

    <!-- Connection Log Panel (collapsible) -->
    <div id="connection-log-panel" class="bg-black/50 border-t border-white/10 overflow-hidden transition-all flex-shrink-0" style="height: 0px;">
        <div class="p-3 space-y-1 text-xs font-mono h-full overflow-y-auto" id="connection-log-content">
            <!-- Logs will be added here -->
        </div>
    </div>

    <!-- Connection Log Toggle Bar -->
    <div class="bg-black/60 border-t border-white/10 px-3 py-1 flex items-center justify-between text-xs flex-shrink-0">
        <div class="flex items-center gap-2">
            <button onclick="toggleConnectionLog()" class="flex items-center gap-1 hover:text-blue-400 transition-colors">
                <span id="log-toggle-icon">‚ñ∂</span>
                <span>Connection Log</span>
            </button>
            <span class="text-white/50" id="log-message-count">(0 messages)</span>
        </div>
        <button onclick="clearConnectionLog()" class="text-white/50 hover:text-red-400 transition-colors">Clear</button>
    </div>
</div>

<!-- Server Control Sidebar -->
<div class="w-80 bg-black/30 backdrop-blur-md border-l border-white/10 p-5 overflow-y-auto">
    <!-- Server Information -->
    <div class="mb-6">
        <h3 class="text-sm font-semibold mb-3 text-white/90">Server Information</h3>
        <div class="space-y-2 text-sm">
            <div class="flex justify-between py-2 border-b border-white/10">
                <span class="text-white/70">Server ID</span>
                <span class="font-medium">{{.ServerID}}</span>
            </div>
            <div class="flex justify-between py-2 border-b border-white/10">
                <span class="text-white/70">Session ID</span>
                <span class="font-mono text-xs">{{.SessionID}}</span>
            </div>
            <div class="flex justify-between py-2 border-b border-white/10">
                <span class="text-white/70">Gateway</span>
                <span class="text-xs">{{.GatewayEndpoint}}</span>
            </div>
            <div class="flex justify-between py-2 border-b border-white/10">
                <span class="text-white/70">Protocol</span>
                <span>SOL/WebSocket</span>
            </div>
            <div class="flex justify-between py-2 border-b border-white/10">
                <span class="text-white/70">Console Type</span>
                <span>Serial Terminal</span>
            </div>
        </div>
    </div>

    <!-- Server State -->
    <div class="mb-6">
        <h3 class="text-sm font-semibold mb-3 text-white/90 flex items-center gap-2">
            Server State
            <div class="w-2 h-2 bg-yellow-400 rounded-full pulse-animation" id="server-state-dot"></div>
        </h3>
        <div class="space-y-2 text-sm">
            <div class="flex justify-between py-2 border-b border-white/10">
                <span class="text-white/70">Power State</span>
                <span id="power-status" class="px-2 py-1 text-xs font-medium rounded-full bg-gray-600 text-white">Unknown</span>
            </div>
            <div class="flex justify-between py-2 border-b border-white/10">
                <span class="text-white/70">BMC Status</span>
                <span id="bmc-status" class="px-2 py-1 text-xs font-medium rounded-full bg-green-600 text-white">Connected</span>
            </div>
            <div class="flex justify-between py-2 border-b border-white/10">
                <span class="text-white/70">Last Check</span>
                <span id="last-check" class="text-xs">--</span>
            </div>
        </div>
    </div>

    <!-- Power Operations -->
    <div class="mb-6">
        <h3 class="text-sm font-semibold mb-3 text-white/90">Power Control</h3>
        <div class="grid grid-cols-2 gap-2">
            <button onclick="powerOperation('on')"
                    class="p-3 bg-gradient-to-r from-green-500 to-emerald-600 rounded-lg text-sm font-medium transition-all hover:-translate-y-0.5 hover:shadow-lg hover:shadow-green-500/25 disabled:opacity-50 disabled:cursor-not-allowed"
                    id="power-on-btn">
                <div class="text-center">
                    <div class="text-lg">‚ö°</div>
                    <div>Power On</div>
                </div>
            </button>
            <button onclick="powerOperation('off')"
                    class="p-3 bg-gradient-to-r from-red-500 to-red-600 rounded-lg text-sm font-medium transition-all hover:-translate-y-0.5 hover:shadow-lg hover:shadow-red-500/25 disabled:opacity-50 disabled:cursor-not-allowed"
                    id="power-off-btn">
                <div class="text-center">
                    <div class="text-lg">‚èª</div>
                    <div>Power Off</div>
                </div>
            </button>
            <button onclick="powerOperation('reset')"
                    class="p-3 bg-gradient-to-r from-orange-500 to-orange-600 rounded-lg text-sm font-medium transition-all hover:-translate-y-0.5 hover:shadow-lg hover:shadow-orange-500/25 disabled:opacity-50 disabled:cursor-not-allowed"
                    id="reset-btn">
                <div class="text-center">
                    <div class="text-lg">üîÑ</div>
                    <div>Reset</div>
                </div>
            </button>
            <button onclick="powerOperation('cycle')"
                    class="p-3 bg-gradient-to-r from-purple-500 to-purple-600 rounded-lg text-sm font-medium transition-all hover:-translate-y-0.5 hover:shadow-lg hover:shadow-purple-500/25 disabled:opacity-50 disabled:cursor-not-allowed"
                    id="cycle-btn">
                <div class="text-center">
                    <div class="text-lg">üîÅ</div>
                    <div>Power Cycle</div>
                </div>
            </button>
        </div>
        <button onclick="refreshPowerStatus(true)"
                class="w-full mt-2 p-2 bg-white/10 hover:bg-white/20 border border-white/20 rounded-lg text-sm font-medium transition-all">
            <span class="inline-block mr-2">üîç</span>Refresh Status
        </button>
    </div>

    <!-- SOL Terminal Controls -->
    <div class="mb-6">
        <h3 class="text-sm font-semibold mb-3 text-white/90">Terminal Controls</h3>
        <div class="space-y-2">
            <button onclick="sendSpecialKey('ESC')"
                    class="w-full p-2 bg-white/10 hover:bg-white/20 border border-white/20 rounded-md text-sm transition-all">
                <span class="inline-block mr-2">‚éã</span>Send ESC
            </button>
            <button onclick="sendSpecialKey('F12')"
                    class="w-full p-2 bg-white/10 hover:bg-white/20 border border-white/20 rounded-md text-sm transition-all">
                <span class="inline-block mr-2">üîß</span>Boot Menu (F12)
            </button>
            <button onclick="sendSpecialKey('DELETE')"
                    class="w-full p-2 bg-white/10 hover:bg-white/20 border border-white/20 rounded-md text-sm transition-all">
                <span class="inline-block mr-2">‚öôÔ∏è</span>BIOS Setup
            </button>
            <button onclick="sendSpecialKey('BREAK')"
                    class="w-full p-2 bg-white/10 hover:bg-white/20 border border-white/20 rounded-md text-sm transition-all">
                <span class="inline-block mr-2">‚è∏Ô∏è</span>Send Break
            </button>
            <button onclick="clearTerminal()"
                    class="w-full p-2 bg-white/10 hover:bg-white/20 border border-white/20 rounded-md text-sm transition-all">
                <span class="inline-block mr-2">üßπ</span>Clear Terminal
            </button>
            <button onclick="copyOutput()"
                    class="w-full p-2 bg-white/10 hover:bg-white/20 border border-white/20 rounded-md text-sm transition-all">
                <span class="inline-block mr-2">üìã</span>Copy Output
            </button>
        </div>
    </div>

    {{template "bmc_info_sidebar" .}}

    <!-- Connection Info -->
    <div class="mb-4">
        <h3 class="text-sm font-semibold mb-3 text-white/90">Connection Info</h3>
        <div class="space-y-2 text-sm">
            <div class="flex justify-between py-1 text-xs">
                <span class="text-white/70">Connected</span>
                <span id="connect-time">--</span>
            </div>
            <div class="flex justify-between py-1 text-xs">
                <span class="text-white/70">Messages</span>
                <span id="message-count">0</span>
            </div>
            <div class="flex justify-between py-1 text-xs">
                <span class="text-white/70">Last Activity</span>
                <span id="last-activity">--</span>
            </div>
        </div>
    </div>
</div>
{{end}}

{{define "scripts"}}
// XTerm.js Terminal Setup
let term = null;
let fitAddon = null;
let webLinksAddon = null;
let ws = null;

// Connection tracking
let messageCounter = 0;
let connectionStart = null;
let powerOperationsInProgress = new Set();
let authToken = null;
let connectionLogCount = 0;
let connectionLogExpanded = false;

// Initialize reconnection manager
let reconnectManager = new ReconnectionManager({
    onReconnect: () => {
        initializeWebSocket();
    },
    onStateChange: (state) => {
        handleReconnectionStateChange(state);
    },
    maxAttempts: 10,
    initialDelay: 1000,
    maxDelay: 30000
});

function handleReconnectionStateChange(state) {
    const cancelBtn = document.getElementById('cancel-reconnect-btn');

    switch(state.state) {
        case 'reconnecting':
            const delaySeconds = Math.ceil(state.delay / 1000);
            logToTerminal(`Auto-reconnecting in ${delaySeconds}s (attempt ${state.attempts}/${state.maxAttempts})`, 'info');
            updateStatus(`Reconnecting (${state.attempts}/${state.maxAttempts})`, 'connecting');
            if (cancelBtn) cancelBtn.classList.remove('hidden');
            break;

        case 'failed':
            logToTerminal(state.reason || 'Max reconnection attempts reached. Click "Reconnect" to try again.', 'error');
            updateStatus('Disconnected', 'error');
            if (cancelBtn) cancelBtn.classList.add('hidden');
            break;

        case 'cancelled':
            logToTerminal('Auto-reconnection cancelled. Click "Reconnect" to reconnect manually.', 'warning');
            updateStatus('Disconnected', 'error');
            if (cancelBtn) cancelBtn.classList.add('hidden');
            break;

        case 'connected':
            updateStatus('Connected', 'connected');
            if (cancelBtn) cancelBtn.classList.add('hidden');
            break;
    }
}

// Initialize XTerm terminal
function initializeTerminal() {
    // Create terminal instance
    term = new Terminal({
        theme: {
            background: '#0a0a0a',
            foreground: '#00ff41',
            cursor: '#00ff41',
            selection: 'rgba(255, 255, 255, 0.3)',
        },
        fontFamily: 'SF Mono, Consolas, Cascadia Code, Monaco, monospace',
        fontSize: 13,
        lineHeight: 1.2,
        cursorBlink: true,
        cursorStyle: 'block',
        scrollback: 10000,
        allowTransparency: true,
        convertEol: true
    });

    // Add addons
    fitAddon = new FitAddon.FitAddon();
    webLinksAddon = new WebLinksAddon.WebLinksAddon();

    term.loadAddon(fitAddon);
    term.loadAddon(webLinksAddon);

    // Mount terminal
    const container = document.getElementById('terminal-container');
    term.open(container);

    // Fit terminal to container
    fitAddon.fit();

    // Handle window resize
    window.addEventListener('resize', () => {
        setTimeout(() => fitAddon.fit(), 10);
    });

    // Terminal input handling
    term.onData(data => {
        // Send raw input data to server via WebSocket (SOL expects binary data, not JSON)
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(data);
        } else {
            logToTerminal('WebSocket not connected - input ignored', 'warning');
        }
    });

    // Initial welcome message - now in connection log instead of terminal
    logToConnectionLog('SOL Console Session Initialized', 'success');
    logToConnectionLog('Server: {{.ServerID}}', 'info');
    logToConnectionLog('Gateway: {{.GatewayEndpoint}}', 'info');
    logToConnectionLog('Session: {{.SessionID}}', 'info');
    logToConnectionLog('Protocol: Serial Over LAN (SOL)', 'info');
}

// Connection log functions (separate from SOL terminal)
function logToConnectionLog(message, type = 'info') {
    const logContent = document.getElementById('connection-log-content');
    const logCountElem = document.getElementById('log-message-count');
    if (!logContent) return;

    const timestamp = new Date().toLocaleTimeString();
    const logEntry = document.createElement('div');
    logEntry.className = 'flex gap-2';

    let colorClass = 'text-white/70';
    let icon = '‚Ä¢';
    switch(type) {
        case 'error':
            colorClass = 'text-red-400';
            icon = '‚úó';
            break;
        case 'success':
            colorClass = 'text-green-400';
            icon = '‚úì';
            break;
        case 'warning':
            colorClass = 'text-yellow-400';
            icon = '‚ö†';
            break;
        case 'info':
            colorClass = 'text-cyan-400';
            icon = '‚Ñπ';
            break;
    }

    logEntry.innerHTML = `
        <span class="text-white/40">[${timestamp}]</span>
        <span class="${colorClass}">${icon}</span>
        <span class="${colorClass}">${message}</span>
    `;

    logContent.appendChild(logEntry);

    // Auto-scroll to bottom
    logContent.scrollTop = logContent.scrollHeight;

    // Update count
    connectionLogCount++;
    if (logCountElem) {
        logCountElem.textContent = `(${connectionLogCount} messages)`;
    }
}

function toggleConnectionLog() {
    const panel = document.getElementById('connection-log-panel');
    const icon = document.getElementById('log-toggle-icon');

    if (connectionLogExpanded) {
        panel.style.height = '0px';
        icon.textContent = '‚ñ∂';
        connectionLogExpanded = false;
    } else {
        panel.style.height = '150px';
        icon.textContent = '‚ñº';
        connectionLogExpanded = true;
    }

    // Re-fit terminal after animation
    setTimeout(() => {
        if (fitAddon) fitAddon.fit();
    }, 300);
}

function clearConnectionLog() {
    const logContent = document.getElementById('connection-log-content');
    const logCountElem = document.getElementById('log-message-count');
    if (logContent) {
        logContent.innerHTML = '';
        connectionLogCount = 0;
        if (logCountElem) {
            logCountElem.textContent = '(0 messages)';
        }
    }
}

// Redirect logToTerminal to connection log instead of SOL terminal
function logToTerminal(message, type = 'info') {
    logToConnectionLog(message, type);
}

// Power Operations using Connect RPC API
async function powerOperation(operation) {
    if (powerOperationsInProgress.has(operation)) {
        return;
    }

    const serverID = '{{.ServerID}}';
    const button = document.getElementById(`${operation === 'on' ? 'power-on' : operation === 'off' ? 'power-off' : operation}-btn`);

    // Disable button and show loading
    if (button) {
        button.disabled = true;
        button.classList.add('opacity-50', 'cursor-not-allowed');
    }

    powerOperationsInProgress.add(operation);
    logToTerminal(`Executing power ${operation} operation...`, 'info');

    try {
        // Map operation to Connect RPC method name
        const methodMap = {
            'on': 'PowerOn',
            'off': 'PowerOff',
            'reset': 'Reset',
            'cycle': 'PowerCycle'
        };

        const method = methodMap[operation];
        if (!method) {
            throw new Error(`Unknown power operation: ${operation}`);
        }

        const response = await fetch(`/gateway.v1.GatewayService/${method}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include', // Send session cookie
            body: JSON.stringify({
                server_id: serverID
            })
        });

        if (response.ok) {
            const result = await response.json();
            logToTerminal(`Power ${operation} operation completed: ${result.message || 'Success'}`, 'success');
            // Refresh power status after successful operation
            setTimeout(() => refreshPowerStatus(), 2000);
        } else {
            const error = await response.text();
            logToTerminal(`Power ${operation} operation failed: ${error}`, 'error');
        }
    } catch (error) {
        logToTerminal(`Power ${operation} operation error: ${error.message}`, 'error');
    } finally {
        powerOperationsInProgress.delete(operation);
        if (button) {
            button.disabled = false;
            button.classList.remove('opacity-50', 'cursor-not-allowed');
        }
    }
}

// Refresh power status using Connect RPC API (silent mode - no terminal logs)
async function refreshPowerStatus(verbose = false) {
    const serverID = '{{.ServerID}}';
    const statusElement = document.getElementById('power-status');
    const lastCheckElement = document.getElementById('last-check');
    const serverStateDot = document.getElementById('server-state-dot');

    try {
        if (verbose) {
            logToTerminal('Refreshing power status...', 'info');
        }

        const response = await fetch('/gateway.v1.GatewayService/GetPowerStatus', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include', // Send session cookie
            body: JSON.stringify({
                server_id: serverID
            })
        });

        if (response.ok) {
            const result = await response.json();

            // Map PowerState enum to string
            const stateMap = {
                'POWER_STATE_UNKNOWN': 'unknown',
                'POWER_STATE_ON': 'on',
                'POWER_STATE_OFF': 'off',
                'POWER_STATE_CYCLING': 'cycling'
            };

            const status = stateMap[result.state] || 'unknown';

            // Update power status display
            if (statusElement) {
                statusElement.textContent = status.charAt(0).toUpperCase() + status.slice(1);
                statusElement.className = 'px-2 py-1 text-xs font-medium rounded-full';

                // Color coding based on status
                if (status === 'on') {
                    statusElement.classList.add('bg-green-600', 'text-white');
                } else if (status === 'off') {
                    statusElement.classList.add('bg-red-600', 'text-white');
                } else {
                    statusElement.classList.add('bg-gray-600', 'text-white');
                }
            }

            // Update server state indicator
            if (serverStateDot) {
                serverStateDot.className = 'w-2 h-2 rounded-full';
                if (status === 'on') {
                    serverStateDot.classList.add('bg-green-400');
                } else if (status === 'off') {
                    serverStateDot.classList.add('bg-red-400');
                } else {
                    serverStateDot.classList.add('bg-gray-400');
                }
            }

            if (lastCheckElement) {
                lastCheckElement.textContent = new Date().toLocaleTimeString();
            }

            if (verbose) {
                logToTerminal(`Power status: ${status}`, 'success');
            }
        } else {
            const error = await response.text();
            if (verbose) {
                logToTerminal(`Failed to get power status: ${error}`, 'error');
            }
        }
    } catch (error) {
        if (verbose) {
            logToTerminal(`Error getting power status: ${error.message}`, 'error');
        }
    }
}

// WebSocket initialization
function initializeWebSocket() {
    const wsUrl = '{{.WebSocketURL}}';

    logToTerminal('Connecting to WebSocket: ' + wsUrl, 'info');

    ws = new WebSocket(wsUrl);

    ws.onopen = function(event) {
        logToTerminal('WebSocket connection established', 'success');
        connectionStart = new Date();

        // Notify reconnection manager of successful connection
        reconnectManager.onConnected();
    };

    ws.onmessage = function(event) {
        // SOL console sends raw binary data, not JSON
        // Write directly to terminal
        try {
            if (event.data) {
                console.log('WebSocket received data:', typeof event.data, 'length:', event.data.length || event.data.size);

                // Handle both text and binary data
                if (typeof event.data === 'string') {
                    term.write(event.data);
                    messageCounter++;
                } else if (event.data instanceof Blob) {
                    // Convert Blob to text
                    event.data.text().then(text => {
                        console.log('Converted Blob to text:', text.length, 'chars');
                        term.write(text);
                        messageCounter++;
                        updateConnectionInfo();
                    });
                    return; // Skip updateConnectionInfo here, it will be called in the promise
                } else {
                    console.warn('Unknown data type received:', typeof event.data);
                }
            }
            updateConnectionInfo();
        } catch (error) {
            console.error('Error processing WebSocket message:', error);
            logToTerminal('Error processing message: ' + error.message, 'error');
        }
    };

    ws.onclose = function(event) {
        const reason = event.reason || (event.wasClean ? 'Connection closed' : 'Connection lost');
        console.log('WebSocket closed:', event.code, reason, 'wasClean:', event.wasClean);
        logToTerminal(`WebSocket connection closed: ${reason} (code: ${event.code})`, 'warning');

        // Notify reconnection manager of disconnection
        reconnectManager.onDisconnected(reason);
    };

    ws.onerror = function(error) {
        console.error('WebSocket error:', error);
        logToTerminal('WebSocket error: ' + error, 'error');
        updateStatus('Error', 'error');
    };
}

function handleWebSocketMessage(message) {
    switch (message.type) {
        case 'welcome':
            logToTerminal('Server: ' + message.data.message, 'success');
            break;
        case 'output':
            term.write(message.data);
            break;
        case 'echo':
            logToTerminal('Echo: ' + JSON.stringify(message.data), 'info');
            break;
        default:
            logToTerminal('Unknown message type: ' + message.type, 'warning');
    }
}

// Utility functions
// No longer needed - session cookies are used automatically via credentials: 'include'

function updateConnectionInfo() {
    if (connectionStart) {
        const duration = Math.floor((new Date() - connectionStart) / 1000);
        const connectTime = document.getElementById('connect-time');
        if (connectTime) {
            connectTime.textContent = formatDuration(duration);
        }
    }

    const messageCount = document.getElementById('message-count');
    const lastActivity = document.getElementById('last-activity');

    if (messageCount) messageCount.textContent = messageCounter;
    if (lastActivity) lastActivity.textContent = new Date().toLocaleTimeString();
}

function formatDuration(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
}


function sendCtrlAltDel() {
    logToTerminal('Sent Ctrl+Alt+Del key combination', 'input');
    logToTerminal('[PLACEHOLDER] Ctrl+Alt+Del would be sent to BMC', 'info');
}

function sendSpecialKey(key) {
    logToTerminal(`Sent special key: ${key}`, 'input');
    logToTerminal(`[PLACEHOLDER] Special key would be sent to BMC: ${key}`, 'info');
}

function clearTerminal() {
    if (term) {
        term.clear();
        logToTerminal('Terminal cleared', 'info');
    }
}

function copyOutput() {
    if (term) {
        const text = term.getSelection();
        if (text) {
            navigator.clipboard.writeText(text).then(() => {
                logToTerminal('Selected text copied to clipboard', 'success');
            }).catch(() => {
                logToTerminal('Failed to copy to clipboard', 'error');
            });
        } else {
            logToTerminal('No text selected', 'warning');
        }
    }
}

function toggleFullscreen() {
    const consoleArea = document.querySelector('.flex-1.flex.flex-col.bg-black\\/20');
    if (document.fullscreenElement) {
        document.exitFullscreen();
        logToTerminal('Exited fullscreen mode', 'info');
    } else {
        if (consoleArea) {
            consoleArea.requestFullscreen();
            logToTerminal('Entered fullscreen mode', 'info');
        }
    }
}

function switchToVNC() {
    // Replace /console/ with /vnc/ in the current URL
    const currentUrl = window.location.pathname;
    const vncUrl = currentUrl.replace('/console/', '/vnc/');
    window.location.href = vncUrl;
}

function cancelAutoReconnect() {
    console.log('Auto-reconnection cancelled by user');
    reconnectManager.cancel();
}

function reconnect() {
    console.log('Manual reconnection triggered');

    // Close existing connection if any
    if (ws && ws.readyState !== WebSocket.CLOSED) {
        ws.close();
    }

    // Clear terminal
    if (term) {
        term.clear();
    }

    // Reset counters
    messageCounter = 0;
    connectionStart = null;

    // Reset and restart reconnection process
    reconnectManager.reset();

    updateStatus('Connecting...', '');
    logToTerminal('Reconnecting to gateway...', 'info');

    setTimeout(() => {
        initializeTerminal();
        initializeWebSocket();
        refreshPowerStatus();
    }, 1000);
}

// Event listeners
document.addEventListener('DOMContentLoaded', function() {
    // Initialize terminal
    initializeTerminal();

    // Initialize WebSocket connection
    initializeWebSocket();

    // Initial power status check (verbose)
    refreshPowerStatus(true);

    // Fetch BMC hardware info
    fetchBMCInfo();
});

// Update connection info every second
setInterval(updateConnectionInfo, 1000);
// Refresh power status every 30 seconds (silent)
setInterval(() => refreshPowerStatus(false), 30000);
{{end}}